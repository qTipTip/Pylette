{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Extract color palettes from images using the command line or Python library  </p> <p> </p> <p> Documentation: https://qtiptip.github.io/Pylette/</p> <p> Source code: qTipTip/Pylette</p>"},{"location":"#what-is-pylette","title":"What is Pylette?","text":"<p>Pylette helps you extract color palettes from images. Use the command-line interface for quick tasks or the Python library for more advanced workflows.</p> <p>Key Features: - Extract palettes from single images or batch process multiple files - Export to JSON format with metadata and hex colors - Support for different colorspaces (RGB, HSV, HLS) - Handle transparent images with alpha channel masking - Fast parallel processing for multiple images - Rich progress display with color previews</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>You can easily install Pylette using pip:</p> <pre><code>pip install Pylette\n</code></pre> <p>Or if you prefer using uv:</p> <pre><code>uv add Pylette\n</code></pre>"},{"location":"#command-line-usage","title":"Command Line Usage","text":"<p>Extract palettes from images using simple commands:</p> <p>Basic Usage</p> <pre><code># Extract 5 colors from an image (shows clean table output)\npylette image.jpg\n\n# Process multiple images and export to JSON files\npylette *.jpg --export-json --output results/\n\n# Extract 8 colors in HSV colorspace with structured export\npylette photo.png --n 8 --colorspace hsv --export-json --output colors.json\n\n# Batch process with parallel processing and table display\npylette images/*.png --n 6 --num-threads 4\n</code></pre> <p>Example Output: <pre><code>\u2713 Extracted 5 colors from sunset.jpg\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Hex      \u2503 RGB             \u2503 Frequency\u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 #FF6B35  \u2502 (255, 107, 53)  \u2502    28.5% \u2502\n\u2502 #F7931E  \u2502 (247, 147, 30)  \u2502    23.2% \u2502\n\u2502 #FFD23F  \u2502 (255, 210, 63)  \u2502    18.7% \u2502\n\u2502 #06FFA5  \u2502 (6, 255, 165)   \u2502    15.4% \u2502\n\u2502 #4ECDC4  \u2502 (78, 205, 196)  \u2502    14.2% \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"#python-library","title":"Python Library","text":"<p>For programmatic usage and advanced workflows:</p> <p>Python API</p> <pre><code>from Pylette import extract_colors\n\n# Extract palette with rich metadata\npalette = extract_colors(image='image.jpg', palette_size=8)\n\n# Access color properties with hex support\nfor color in palette.colors:\n    print(f\"RGB: {color.rgb}\")\n    print(f\"Hex: {color.hex}\")\n    print(f\"HSV: {color.hsv}\")\n    print(f\"Frequency: {color.freq:.2%}\")\n\n# Export to structured JSON\npalette.to_json(filename='palette.json', colorspace='hsv')\n\n# Access metadata\nprint(f\"Source: {palette.image_source}\")\nprint(f\"Extraction time: {palette.processing_stats['extraction_time']:.2f}s\")\n\n# Simple export method\npalette.export('my_colors', colorspace='hls', include_metadata=True)\n</code></pre> <p>Batch Processing</p> <pre><code>from Pylette import batch_extract_colors\n\n# Process multiple images with parallel processing\nresults = batch_extract_colors(\n    images=['image1.jpg', 'image2.png', 'image3.jpg'],\n    palette_size=8,\n    max_workers=4,\n    mode='KMeans'\n)\n\n# Handle results\nfor result in results:\n    if result.success and result.palette:\n        print(f\"\u2713 {result.source}: {len(result.palette.colors)} colors\")\n        result.palette.export(f\"{result.source}_palette\")\n    else:\n        print(f\"\u2717 {result.source}: {result.error}\")\n</code></pre> <p>The Python library provides full programmatic access to all CLI features plus detailed metadata and customization options.</p> <p>Working with Transparent Images</p> <p>For images with transparency (PNG files with alpha channels), you can use the <code>alpha_mask_threshold</code> parameter to exclude transparent or semi-transparent pixels:</p> <pre><code>from Pylette import extract_colors\n\n# Extract colors from a transparent PNG, ignoring pixels with alpha &lt; 128\npalette = extract_colors(\n    image='transparent_image.png',\n    palette_size=10,\n    alpha_mask_threshold=128\n)\n</code></pre> <p>The <code>alpha_mask_threshold</code> parameter accepts values from 0-255, where pixels with alpha values below this threshold are excluded from color extraction.</p>"},{"location":"#json-export-format","title":"JSON Export Format","text":"<p>Pylette exports rich JSON data:</p> <p>JSON Structure</p> <pre><code>{\n  \"colors\": [\n    {\n      \"rgb\": [142, 152, 174],\n      \"hex\": \"#8E98AE\",\n      \"frequency\": 0.25\n    }\n  ],\n  \"palette_size\": 5,\n  \"colorspace\": \"rgb\",\n  \"metadata\": {\n    \"image_source\": \"photo.jpg\",\n    \"extraction_params\": {\n      \"palette_size\": 5,\n      \"mode\": \"KMeans\"\n    },\n    \"processing_stats\": {\n      \"extraction_time\": 0.234\n    }\n  }\n}\n</code></pre> <p>Different colorspaces use semantic field names: - RGB: <code>{\"rgb\": [255, 128, 64], \"hex\": \"#FF8040\", \"frequency\": 0.25}</code> - HSV: <code>{\"hsv\": [0.08, 0.75, 1.0], \"rgb\": [255, 128, 64], \"hex\": \"#FF8040\", \"frequency\": 0.25}</code> - HLS: <code>{\"hls\": [0.08, 0.63, 0.75], \"rgb\": [255, 128, 64], \"hex\": \"#FF8040\", \"frequency\": 0.25}</code></p>"},{"location":"#export-options","title":"Export Options","text":"<p>Control how your palettes are saved:</p> <p>Export Commands</p> <pre><code># Individual JSON files for each image\npylette *.jpg --export-json --output palettes/\n# Creates: palettes/palette_001.json, palettes/palette_002.json, etc.\n\n# Combined JSON file with all palettes\npylette *.jpg --export-json --output all_colors.json\n\n# Export with different colorspace\npylette image.jpg --colorspace hsv --export-json --output hsv_palette.json\n\n# Suppress table output, only export JSON\npylette *.png --export-json --output results/ --no-stdout\n</code></pre>"},{"location":"#example-palettes","title":"Example Palettes","text":"<p>Check out these palettes extracted using Pylette! The top row corresponds to extraction using K-Means, and the bottom row corresponds to Median-Cut extraction. The colors are sorted by luminosity.</p> Original Image Extracted Palette"},{"location":"#how-pylette-works","title":"How Pylette Works","text":"<p>Pylette uses various color quantization algorithms to extract the most representative colors from your images. Currently, it supports:</p> <ol> <li>K-Means clustering</li> <li>Median-Cut algorithm</li> </ol>"},{"location":"#wed-love-your-feedback-and-contributions","title":"We'd Love Your Feedback And Contributions!","text":"<p>Pylette is an ongoing project, and we're always looking to improve it. If you have any suggestions, questions, or just want to share how you're using Pylette, please don't hesitate to reach out, or make a pull request on our GitHub repository.</p> <p>Happy color extracting!</p>"},{"location":"reference/","title":"Reference","text":"<p>Here you can find the reference for the user facing API of Pylette. This consists of the <code>extract_colors</code> function, which is used to extract a color palette from an image, and the <code>Palette</code> and <code>Color</code> classes, which are used to work with the extracted color palette.</p>"},{"location":"reference/#key-features","title":"Key Features","text":"<ul> <li>JSON Export: Export palettes to structured JSON format with metadata</li> <li>Hex Colors: Access hex color codes through the <code>Color.hex</code> property</li> <li>Semantic Fields: Export uses semantic field names (rgb, hsv, hls) instead of generic values</li> <li>Metadata: Rich metadata including extraction parameters, timing, and image info</li> <li>Batch Processing: Process multiple images with parallel execution support</li> </ul>"},{"location":"reference/#Pylette.extract_colors","title":"<code>Pylette.extract_colors</code>","text":"<p>Extracts a set of 'palette_size' colors from the given image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ImageInput</code> <p>The input image.</p> required <code>palette_size</code> <code>int</code> <p>The number of colors to extract.</p> <code>5</code> <code>resize</code> <code>bool</code> <p>Whether to resize the image before processing.</p> <code>True</code> <code>mode</code> <code>ExtractionMethod</code> <p>The color quantization algorithm to use.</p> <code>KM</code> <code>sort_mode</code> <code>Literal['luminance', 'frequency'] | None</code> <p>The mode to sort colors.</p> <code>None</code> <code>alpha_mask_threshold</code> <code>int | None</code> <p>Optional integer between 0, 255. Any pixel with alpha less than this threshold will be discarded from calculations.</p> <code>None</code> <p>Returns:     Palette: A palette of the extracted colors.</p> <p>Examples:</p> <p>Colors can be extracted from a variety of sources, including local files, byte streams, URLs, and numpy arrays.</p> <pre><code>&gt;&gt;&gt; extract_colors(\"path/to/image.jpg\", palette_size=5, resize=True, mode=\"KM\", sort_mode=\"luminance\")\n&gt;&gt;&gt; extract_colors(b\"image_bytes\", palette_size=5, resize=True, mode=\"KM\", sort_mode=\"luminance\")\n</code></pre> Source code in <code>Pylette/src/color_extraction.py</code> <pre><code>def extract_colors(\n    image: ImageInput,\n    palette_size: int = 5,\n    resize: bool = True,\n    mode: ExtractionMethod = ExtractionMethod.KM,\n    sort_mode: Literal[\"luminance\", \"frequency\"] | None = None,\n    alpha_mask_threshold: int | None = None,\n) -&gt; Palette:\n    \"\"\"\n    Extracts a set of 'palette_size' colors from the given image.\n\n    Parameters:\n        image: The input image.\n        palette_size: The number of colors to extract.\n        resize: Whether to resize the image before processing.\n        mode: The color quantization algorithm to use.\n        sort_mode: The mode to sort colors.\n        alpha_mask_threshold: Optional integer between 0, 255.\n            Any pixel with alpha less than this threshold will be discarded from calculations.\n    Returns:\n        Palette: A palette of the extracted colors.\n\n    Examples:\n        Colors can be extracted from a variety of sources, including local files, byte streams, URLs, and numpy arrays.\n\n        &gt;&gt;&gt; extract_colors(\"path/to/image.jpg\", palette_size=5, resize=True, mode=\"KM\", sort_mode=\"luminance\")\n        &gt;&gt;&gt; extract_colors(b\"image_bytes\", palette_size=5, resize=True, mode=\"KM\", sort_mode=\"luminance\")\n    \"\"\"\n\n    start_time = time.time()\n\n    source_type = _get_source_type_from_image_input(image)\n    # Normalize input to PIL Image and convert to RGBA\n    img_obj = _normalize_image_input(image)\n    original_size = img_obj.size\n    img = img_obj.convert(\"RGBA\")\n\n    # Store original image info\n    image_info = ImageInfo(\n        original_size=original_size,\n        processed_size=img.size if not resize else (256, 256),\n        format=getattr(img_obj, \"format\", None),\n        mode=img.mode,\n        has_alpha=img.mode in (\"RGBA\", \"LA\") or \"transparency\" in img_obj.info,\n    )\n\n    if resize:\n        img = img.resize((256, 256))\n        image_info[\"processed_size\"] = (256, 256)\n\n    width, height = img.size\n    arr = np.asarray(img)\n\n    if alpha_mask_threshold is None:\n        alpha_mask_threshold = 0\n\n    alpha_mask = arr[:, :, 3] &lt;= alpha_mask_threshold\n    valid_pixels = arr[~alpha_mask]\n\n    if len(valid_pixels) == 0:\n        raise ValueError(\n            f\"No valid pixels remain after applying alpha mask with threshold {alpha_mask_threshold}. \"\n            f\"Try using a lower alpha-mask-threshold value or check if your image has transparency.\"\n        )\n\n    # Color extraction\n    match mode:\n        case ExtractionMethod.KM:\n            colors = k_means_extraction(valid_pixels, height, width, palette_size)\n        case ExtractionMethod.MC:\n            colors = median_cut_extraction(valid_pixels, height, width, palette_size)\n\n    if colors:\n        if sort_mode == \"luminance\":\n            colors.sort(key=lambda c: c.luminance, reverse=False)\n        else:\n            colors.sort(reverse=True)\n\n    end_time = time.time()\n\n    # Build comprehensive metadata\n    metadata = PaletteMetaData(\n        image_source=_get_descriptive_image_source(image, img_obj),\n        source_type=source_type,\n        extraction_params=ExtractionParams(\n            palette_size=palette_size,\n            mode=mode,\n            sort_mode=sort_mode,\n            resize=resize,\n            alpha_mask_threshold=alpha_mask_threshold,\n        ),\n        image_info=image_info,\n        processing_stats=ProcessingStats(\n            total_pixels=width * height,\n            valid_pixels=len(valid_pixels),\n            extraction_time=end_time - start_time,\n            timestamp=datetime.now().isoformat(),\n        ),\n    )\n\n    return Palette(colors, metadata=metadata)\n</code></pre>"},{"location":"reference/#Pylette.batch_extract_colors","title":"<code>Pylette.batch_extract_colors</code>","text":"<p>Extract colors from multiple images in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>progress_callback</code> <code>Callable[[int, BatchResult], None] | None</code> <p>Optional callback function called when each task completes.              Receives (task_number, result) as arguments.</p> <code>None</code> Source code in <code>Pylette/src/color_extraction.py</code> <pre><code>def batch_extract_colors(\n    images: Sequence[ImageInput],\n    palette_size: int = 5,\n    resize: bool = True,\n    mode: ExtractionMethod = ExtractionMethod.KM,\n    sort_mode: Literal[\"luminance\", \"frequency\"] | None = None,\n    alpha_mask_threshold: int | None = None,\n    max_workers: int | None = None,\n    progress_callback: Callable[[int, BatchResult], None] | None = None,\n) -&gt; list[BatchResult]:\n    \"\"\"Extract colors from multiple images in parallel.\n\n    Args:\n        progress_callback: Optional callback function called when each task completes.\n                         Receives (task_number, result) as arguments.\n    \"\"\"\n\n    def thread_fn(image: ImageInput):\n        return extract_colors(\n            image=image,\n            palette_size=palette_size,\n            resize=resize,\n            mode=mode,\n            sort_mode=sort_mode,\n            alpha_mask_threshold=alpha_mask_threshold,\n        )\n\n    results: list[BatchResult] = []\n    task_number = 1\n\n    with ThreadPoolExecutor(max_workers=max_workers, thread_name_prefix=\"pylette\") as executor:\n        futures_to_image_map = {executor.submit(thread_fn, image): image for image in images}\n\n        for future in as_completed(futures_to_image_map):\n            source_image = futures_to_image_map[future]\n            try:\n                r = future.result()\n                batch_result = BatchResult(source=source_image, result=r)\n                results.append(batch_result)\n                if progress_callback:\n                    progress_callback(task_number, batch_result)\n            except Exception as e:\n                batch_result = BatchResult(source=source_image, exception=e)\n                results.append(batch_result)\n                if progress_callback:\n                    progress_callback(task_number, batch_result)\n            task_number += 1\n\n    # Return results in original order\n    source_to_result = {r.source: r for r in results}\n    return [source_to_result[source] for source in images]\n</code></pre>"},{"location":"reference/#Pylette.Palette","title":"<code>Pylette.Palette</code>","text":"Source code in <code>Pylette/src/palette.py</code> <pre><code>class Palette:\n    def __init__(self, colors: list[Color], metadata: PaletteMetaData | None = None):\n        \"\"\"\n        Initializes a color palette with a list of Color objects.\n\n        Parameters:\n            colors (list[Color]): A list of Color objects.\n        \"\"\"\n\n        self.colors = colors\n        self.frequencies = [c.freq for c in colors]\n        self.number_of_colors = len(colors)\n        self.metadata = metadata\n\n    def _generate_palette_image(self, w: int = 50, h: int = 50) -&gt; Image.Image:\n        \"\"\"\n        Helper method to generate a palette image.\n\n        Parameters:\n            w (int): Width of each color component.\n            h (int): Height of each color component.\n\n        Returns:\n            PIL.Image.Image: The generated palette image.\n        \"\"\"\n        img = Image.new(\"RGB\", size=(w * self.number_of_colors, h))\n        arr = np.asarray(img).copy()\n        for i in range(self.number_of_colors):\n            c = self.colors[i]\n            arr[:, i * h : (i + 1) * h, :] = c.rgb\n        return Image.fromarray(arr, \"RGB\")\n\n    def save(\n        self,\n        w: int = 50,\n        h: int = 50,\n        filename: str = \"color_palette\",\n        extension: str = \"jpg\",\n    ) -&gt; None:\n        \"\"\"\n        Saves the color palette as an image.\n\n        Parameters:\n            w (int): Width of each color component.\n            h (int): Height of each color component.\n            filename (str): Filename.\n            extension (str): File extension.\n        \"\"\"\n        img = self._generate_palette_image(w, h)\n        img.save(f\"{filename}.{extension}\")\n\n    def display(\n        self,\n        w: int = 50,\n        h: int = 50,\n        save_to_file: bool = False,\n        filename: str = \"color_palette\",\n        extension: str = \"jpg\",\n    ) -&gt; None:\n        \"\"\"\n        Displays the color palette as an image, with an option for saving the image.\n\n        Parameters:\n            w (int): Width of each color component.\n            h (int): Height of each color component.\n            save_to_file (bool): Whether to save the file or not.\n            filename (str): Filename.\n            extension (str): File extension.\n        \"\"\"\n        img = self._generate_palette_image(w, h)\n        img.show()\n\n        if save_to_file:\n            self.save(w, h, filename, extension)\n\n    def __getitem__(self, item: int) -&gt; Color:\n        return self.colors[item]\n\n    def __len__(self) -&gt; int:\n        return self.number_of_colors\n\n    def random_color(self, N: int, mode: str = \"frequency\") -&gt; list[Color]:\n        \"\"\"\n        Returns N random colors from the palette, either using the frequency of each color, or choosing uniformly.\n\n        Parameters:\n            N (int): Number of random colors to return.\n            mode (str): Mode to use for selection. Can be \"frequency\" or \"uniform\".\n\n        Returns:\n            list[Color]: List of N random colors from the palette.\n        \"\"\"\n\n        if mode == \"frequency\":\n            # Convert to numpy-compatible format for weighted selection\n            colors_array = np.array(range(len(self.colors)))\n            indices = np.random.choice(colors_array, size=N, p=self.frequencies)\n            return [self.colors[i] for i in indices]\n        elif mode == \"uniform\":\n            # Uniform selection without weights\n            colors_array = np.array(range(len(self.colors)))\n            indices = np.random.choice(colors_array, size=N)\n            return [self.colors[i] for i in indices]\n        else:\n            raise ValueError(f\"Invalid mode: {mode}. Must be 'frequency' or 'uniform'.\")\n\n    def to_json(\n        self,\n        filename: str | None = None,\n        colorspace: ColorSpace = ColorSpace.RGB,\n        include_metadata: bool = True,\n    ) -&gt; dict[str, object] | None:\n        \"\"\"\n        Exports the palette to JSON format.\n\n        Parameters:\n            filename (str | None): File to save to. If None, returns the dictionary.\n            colorspace (Literal[\"rgb\", \"hsv\", \"hls\"]): Color space to use.\n            include_metadata (bool): Whether to include palette metadata.\n\n        Returns:\n            dict | None: The palette data as a dictionary if filename is None.\n        \"\"\"\n\n        # Build the palette data\n        palette_data: dict[str, object] = {\n            \"colors\": [],\n            \"palette_size\": self.number_of_colors,\n            \"colorspace\": colorspace,\n        }\n\n        colors_list = []\n        # Add color data\n        for color in self.colors:\n            color_values = color.get_colors(colorspace)\n            color_data: dict[str, object] = {\n                \"frequency\": float(color.freq),\n            }\n\n            # Add colorspace-specific field\n            colorspace_field = colorspace.value.lower()  # \"rgb\", \"hsv\", \"hls\"\n            if colorspace == ColorSpace.RGB:\n                # RGB values should be integers\n                color_data[colorspace_field] = [int(v) if isinstance(v, np.integer) else v for v in color_values]\n            else:\n                # HSV/HLS values should be floats\n                color_data[colorspace_field] = [\n                    float(v) if isinstance(v, (np.integer, np.floating)) else v for v in color_values\n                ]\n\n            # Add hex (always present, derived from RGB)\n            color_data[\"hex\"] = color.hex\n\n            # Add RGB reference if colorspace is not RGB\n            if colorspace != ColorSpace.RGB:\n                color_data[\"rgb\"] = [int(v) if isinstance(v, np.integer) else v for v in color.rgb]\n\n            colors_list.append(color_data)\n\n        palette_data[\"colors\"] = colors_list\n\n        # Add metadata if requested and available\n        if include_metadata and self.metadata:\n            metadata_dict: dict[str, object] = {}\n\n            if \"image_source\" in self.metadata:\n                metadata_dict[\"image_source\"] = self.metadata[\"image_source\"]\n            if \"source_type\" in self.metadata:\n                metadata_dict[\"source_type\"] = self.metadata[\"source_type\"]\n            if \"extraction_params\" in self.metadata:\n                metadata_dict[\"extraction_params\"] = self.metadata[\"extraction_params\"]\n            if \"image_info\" in self.metadata:\n                metadata_dict[\"image_info\"] = self.metadata[\"image_info\"]\n            if \"processing_stats\" in self.metadata:\n                metadata_dict[\"processing_stats\"] = self.metadata[\"processing_stats\"]\n\n            palette_data[\"metadata\"] = metadata_dict\n\n        # Save to file if filename provided\n        if filename is not None:\n            with open(filename, \"w\") as f:\n                json.dump(palette_data, f, indent=2)\n            return None\n\n        # Return data if no filename provided\n        return palette_data\n\n    def export(\n        self,\n        filename: str,\n        colorspace: ColorSpace = ColorSpace.RGB,\n        include_metadata: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Export palette to JSON format.\n\n        Parameters:\n            filename (str): File to save to (extension will be added automatically if not present).\n            colorspace (ColorSpace): Color space to use.\n            include_metadata (bool): Whether to include metadata.\n        \"\"\"\n\n        # Add .json extension if not present\n        if not filename.endswith(\".json\"):\n            filename = f\"{filename}.json\"\n\n        self.to_json(filename=filename, colorspace=colorspace, include_metadata=include_metadata)\n\n    def __str__(self):\n        return \"\".join([\"({}, {}, {}, {}) \\n\".format(c.rgb[0], c.rgb[1], c.rgb[2], c.freq) for c in self.colors])\n\n    # Convenient metadata accessors\n    @property\n    def image_source(self) -&gt; str | None:\n        \"\"\"Get the image source from metadata.\"\"\"\n        return self.metadata.get(\"image_source\") if self.metadata else None\n\n    @property\n    def source_type(self) -&gt; SourceType | None:\n        \"\"\"Get the source type from metadata.\"\"\"\n        return self.metadata.get(\"source_type\") if self.metadata else None\n\n    @property\n    def extraction_params(self) -&gt; ExtractionParams | None:\n        \"\"\"Get the extraction parameters from metadata.\"\"\"\n        return self.metadata.get(\"extraction_params\") if self.metadata else None\n\n    @property\n    def image_info(self) -&gt; ImageInfo | None:\n        \"\"\"Get the image information from metadata.\"\"\"\n        return self.metadata.get(\"image_info\") if self.metadata else None\n\n    @property\n    def processing_stats(self) -&gt; ProcessingStats | None:\n        \"\"\"Get the processing statistics from metadata.\"\"\"\n        return self.metadata.get(\"processing_stats\") if self.metadata else None\n</code></pre>"},{"location":"reference/#Pylette.Palette.extraction_params","title":"<code>extraction_params: ExtractionParams | None</code>  <code>property</code>","text":"<p>Get the extraction parameters from metadata.</p>"},{"location":"reference/#Pylette.Palette.image_info","title":"<code>image_info: ImageInfo | None</code>  <code>property</code>","text":"<p>Get the image information from metadata.</p>"},{"location":"reference/#Pylette.Palette.image_source","title":"<code>image_source: str | None</code>  <code>property</code>","text":"<p>Get the image source from metadata.</p>"},{"location":"reference/#Pylette.Palette.processing_stats","title":"<code>processing_stats: ProcessingStats | None</code>  <code>property</code>","text":"<p>Get the processing statistics from metadata.</p>"},{"location":"reference/#Pylette.Palette.source_type","title":"<code>source_type: SourceType | None</code>  <code>property</code>","text":"<p>Get the source type from metadata.</p>"},{"location":"reference/#Pylette.Palette.__init__","title":"<code>__init__</code>","text":"<p>Initializes a color palette with a list of Color objects.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>list[Color]</code> <p>A list of Color objects.</p> required Source code in <code>Pylette/src/palette.py</code> <pre><code>def __init__(self, colors: list[Color], metadata: PaletteMetaData | None = None):\n    \"\"\"\n    Initializes a color palette with a list of Color objects.\n\n    Parameters:\n        colors (list[Color]): A list of Color objects.\n    \"\"\"\n\n    self.colors = colors\n    self.frequencies = [c.freq for c in colors]\n    self.number_of_colors = len(colors)\n    self.metadata = metadata\n</code></pre>"},{"location":"reference/#Pylette.Palette.display","title":"<code>display</code>","text":"<p>Displays the color palette as an image, with an option for saving the image.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>int</code> <p>Width of each color component.</p> <code>50</code> <code>h</code> <code>int</code> <p>Height of each color component.</p> <code>50</code> <code>save_to_file</code> <code>bool</code> <p>Whether to save the file or not.</p> <code>False</code> <code>filename</code> <code>str</code> <p>Filename.</p> <code>'color_palette'</code> <code>extension</code> <code>str</code> <p>File extension.</p> <code>'jpg'</code> Source code in <code>Pylette/src/palette.py</code> <pre><code>def display(\n    self,\n    w: int = 50,\n    h: int = 50,\n    save_to_file: bool = False,\n    filename: str = \"color_palette\",\n    extension: str = \"jpg\",\n) -&gt; None:\n    \"\"\"\n    Displays the color palette as an image, with an option for saving the image.\n\n    Parameters:\n        w (int): Width of each color component.\n        h (int): Height of each color component.\n        save_to_file (bool): Whether to save the file or not.\n        filename (str): Filename.\n        extension (str): File extension.\n    \"\"\"\n    img = self._generate_palette_image(w, h)\n    img.show()\n\n    if save_to_file:\n        self.save(w, h, filename, extension)\n</code></pre>"},{"location":"reference/#Pylette.Palette.export","title":"<code>export</code>","text":"<p>Export palette to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File to save to (extension will be added automatically if not present).</p> required <code>colorspace</code> <code>ColorSpace</code> <p>Color space to use.</p> <code>RGB</code> <code>include_metadata</code> <code>bool</code> <p>Whether to include metadata.</p> <code>True</code> Source code in <code>Pylette/src/palette.py</code> <pre><code>def export(\n    self,\n    filename: str,\n    colorspace: ColorSpace = ColorSpace.RGB,\n    include_metadata: bool = True,\n) -&gt; None:\n    \"\"\"\n    Export palette to JSON format.\n\n    Parameters:\n        filename (str): File to save to (extension will be added automatically if not present).\n        colorspace (ColorSpace): Color space to use.\n        include_metadata (bool): Whether to include metadata.\n    \"\"\"\n\n    # Add .json extension if not present\n    if not filename.endswith(\".json\"):\n        filename = f\"{filename}.json\"\n\n    self.to_json(filename=filename, colorspace=colorspace, include_metadata=include_metadata)\n</code></pre>"},{"location":"reference/#Pylette.Palette.random_color","title":"<code>random_color</code>","text":"<p>Returns N random colors from the palette, either using the frequency of each color, or choosing uniformly.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Number of random colors to return.</p> required <code>mode</code> <code>str</code> <p>Mode to use for selection. Can be \"frequency\" or \"uniform\".</p> <code>'frequency'</code> <p>Returns:</p> Type Description <code>list[Color]</code> <p>list[Color]: List of N random colors from the palette.</p> Source code in <code>Pylette/src/palette.py</code> <pre><code>def random_color(self, N: int, mode: str = \"frequency\") -&gt; list[Color]:\n    \"\"\"\n    Returns N random colors from the palette, either using the frequency of each color, or choosing uniformly.\n\n    Parameters:\n        N (int): Number of random colors to return.\n        mode (str): Mode to use for selection. Can be \"frequency\" or \"uniform\".\n\n    Returns:\n        list[Color]: List of N random colors from the palette.\n    \"\"\"\n\n    if mode == \"frequency\":\n        # Convert to numpy-compatible format for weighted selection\n        colors_array = np.array(range(len(self.colors)))\n        indices = np.random.choice(colors_array, size=N, p=self.frequencies)\n        return [self.colors[i] for i in indices]\n    elif mode == \"uniform\":\n        # Uniform selection without weights\n        colors_array = np.array(range(len(self.colors)))\n        indices = np.random.choice(colors_array, size=N)\n        return [self.colors[i] for i in indices]\n    else:\n        raise ValueError(f\"Invalid mode: {mode}. Must be 'frequency' or 'uniform'.\")\n</code></pre>"},{"location":"reference/#Pylette.Palette.save","title":"<code>save</code>","text":"<p>Saves the color palette as an image.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>int</code> <p>Width of each color component.</p> <code>50</code> <code>h</code> <code>int</code> <p>Height of each color component.</p> <code>50</code> <code>filename</code> <code>str</code> <p>Filename.</p> <code>'color_palette'</code> <code>extension</code> <code>str</code> <p>File extension.</p> <code>'jpg'</code> Source code in <code>Pylette/src/palette.py</code> <pre><code>def save(\n    self,\n    w: int = 50,\n    h: int = 50,\n    filename: str = \"color_palette\",\n    extension: str = \"jpg\",\n) -&gt; None:\n    \"\"\"\n    Saves the color palette as an image.\n\n    Parameters:\n        w (int): Width of each color component.\n        h (int): Height of each color component.\n        filename (str): Filename.\n        extension (str): File extension.\n    \"\"\"\n    img = self._generate_palette_image(w, h)\n    img.save(f\"{filename}.{extension}\")\n</code></pre>"},{"location":"reference/#Pylette.Palette.to_json","title":"<code>to_json</code>","text":"<p>Exports the palette to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>File to save to. If None, returns the dictionary.</p> <code>None</code> <code>colorspace</code> <code>Literal[rgb, hsv, hls]</code> <p>Color space to use.</p> <code>RGB</code> <code>include_metadata</code> <code>bool</code> <p>Whether to include palette metadata.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, object] | None</code> <p>dict | None: The palette data as a dictionary if filename is None.</p> Source code in <code>Pylette/src/palette.py</code> <pre><code>def to_json(\n    self,\n    filename: str | None = None,\n    colorspace: ColorSpace = ColorSpace.RGB,\n    include_metadata: bool = True,\n) -&gt; dict[str, object] | None:\n    \"\"\"\n    Exports the palette to JSON format.\n\n    Parameters:\n        filename (str | None): File to save to. If None, returns the dictionary.\n        colorspace (Literal[\"rgb\", \"hsv\", \"hls\"]): Color space to use.\n        include_metadata (bool): Whether to include palette metadata.\n\n    Returns:\n        dict | None: The palette data as a dictionary if filename is None.\n    \"\"\"\n\n    # Build the palette data\n    palette_data: dict[str, object] = {\n        \"colors\": [],\n        \"palette_size\": self.number_of_colors,\n        \"colorspace\": colorspace,\n    }\n\n    colors_list = []\n    # Add color data\n    for color in self.colors:\n        color_values = color.get_colors(colorspace)\n        color_data: dict[str, object] = {\n            \"frequency\": float(color.freq),\n        }\n\n        # Add colorspace-specific field\n        colorspace_field = colorspace.value.lower()  # \"rgb\", \"hsv\", \"hls\"\n        if colorspace == ColorSpace.RGB:\n            # RGB values should be integers\n            color_data[colorspace_field] = [int(v) if isinstance(v, np.integer) else v for v in color_values]\n        else:\n            # HSV/HLS values should be floats\n            color_data[colorspace_field] = [\n                float(v) if isinstance(v, (np.integer, np.floating)) else v for v in color_values\n            ]\n\n        # Add hex (always present, derived from RGB)\n        color_data[\"hex\"] = color.hex\n\n        # Add RGB reference if colorspace is not RGB\n        if colorspace != ColorSpace.RGB:\n            color_data[\"rgb\"] = [int(v) if isinstance(v, np.integer) else v for v in color.rgb]\n\n        colors_list.append(color_data)\n\n    palette_data[\"colors\"] = colors_list\n\n    # Add metadata if requested and available\n    if include_metadata and self.metadata:\n        metadata_dict: dict[str, object] = {}\n\n        if \"image_source\" in self.metadata:\n            metadata_dict[\"image_source\"] = self.metadata[\"image_source\"]\n        if \"source_type\" in self.metadata:\n            metadata_dict[\"source_type\"] = self.metadata[\"source_type\"]\n        if \"extraction_params\" in self.metadata:\n            metadata_dict[\"extraction_params\"] = self.metadata[\"extraction_params\"]\n        if \"image_info\" in self.metadata:\n            metadata_dict[\"image_info\"] = self.metadata[\"image_info\"]\n        if \"processing_stats\" in self.metadata:\n            metadata_dict[\"processing_stats\"] = self.metadata[\"processing_stats\"]\n\n        palette_data[\"metadata\"] = metadata_dict\n\n    # Save to file if filename provided\n    if filename is not None:\n        with open(filename, \"w\") as f:\n            json.dump(palette_data, f, indent=2)\n        return None\n\n    # Return data if no filename provided\n    return palette_data\n</code></pre>"},{"location":"reference/#Pylette.Color","title":"<code>Pylette.Color</code>","text":"Source code in <code>Pylette/src/color.py</code> <pre><code>class Color(object):\n    def __init__(self, rgba: tuple[int, ...], frequency: float):\n        \"\"\"\n        Initializes a Color object with RGBA values and frequency.\n\n        Parameters:\n            rgba (tuple[int, ...]): A tuple of RGBA values.\n            frequency (float): The frequency of the color.\n        \"\"\"\n        assert len(rgba) == 4, \"RGBA values must be a tuple of length 4\"\n        *rgb, alpha = rgba\n        self.rgb = cast(tuple[int, int, int], rgb)\n        self.rgba = rgba\n        self.a = alpha\n        self.freq: float = frequency\n        self.weight = alpha / 255.0\n\n    def display(self, w: int = 50, h: int = 50) -&gt; None:\n        \"\"\"\n        Displays the color in a window of specified width and height.\n\n        Parameters:\n        w (int): Width of the window in pixels.\n        h (int): Height of the window in pixels.\n        \"\"\"\n\n        from PIL import Image\n\n        img = Image.new(\"RGBA\", size=(w, h), color=self.rgba)\n        img.show()\n\n    def __lt__(self, other: \"Color\") -&gt; bool:\n        \"\"\"\n        Compares the frequency of this color with another color.\n\n        Parameters:\n            other (Color): The other Color object to compare with.\n\n        Returns:\n            bool: True if the frequency of this color is less than the frequency of the other color, False otherwise.\n        \"\"\"\n        return self.freq &lt; other.freq\n\n    def get_colors(self, colorspace: ColorSpace = ColorSpace.RGB) -&gt; tuple[int, ...] | tuple[float, ...]:\n        \"\"\"\n        Returns the color values in the specified color space.\n\n        Parameters:\n            colorspace (ColorSpace): The color space to use.\n\n        Returns:\n            tuple[int, ...] | tuple[float, ...]: The color values in the specified color space.\n        \"\"\"\n        colors = {ColorSpace.RGB: self.rgb, ColorSpace.HSV: self.hsv, ColorSpace.HLS: self.hls}\n        return colors[colorspace]\n\n    @property\n    def hsv(self) -&gt; tuple[float, float, float]:\n        \"\"\"\n        Converts the RGB color to HSV color space.\n\n        Returns:\n            tuple[float, float, float]: The color values in HSV color space.\n        \"\"\"\n        return colorsys.rgb_to_hsv(r=self.rgb[0] / 255, g=self.rgb[1] / 255, b=self.rgb[2] / 255)\n\n    @property\n    def hls(self) -&gt; tuple[float, float, float]:\n        \"\"\"\n        Converts the RGB color to HLS color space.\n\n        Returns:\n            tuple[float, float, float]: The color values in HLS color space.\n        \"\"\"\n        return colorsys.rgb_to_hls(r=self.rgb[0] / 255, g=self.rgb[1] / 255, b=self.rgb[2] / 255)\n\n    @property\n    def hex(self) -&gt; str:\n        \"\"\"\n        Returns the color as a hexadecimal string.\n\n        Returns:\n            str: The color in hexadecimal format (e.g., \"#FF5733\").\n        \"\"\"\n        return f\"#{self.rgb[0]:02X}{self.rgb[1]:02X}{self.rgb[2]:02X}\"\n\n    @property\n    def luminance(self) -&gt; float:\n        \"\"\"\n        Calculates the luminance of the color.\n\n        Returns:\n        float: The luminance of the color.\n        \"\"\"\n        return np.dot(luminance_weights, self.rgb)\n</code></pre>"},{"location":"reference/#Pylette.Color.hex","title":"<code>hex: str</code>  <code>property</code>","text":"<p>Returns the color as a hexadecimal string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The color in hexadecimal format (e.g., \"#FF5733\").</p>"},{"location":"reference/#Pylette.Color.hls","title":"<code>hls: tuple[float, float, float]</code>  <code>property</code>","text":"<p>Converts the RGB color to HLS color space.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The color values in HLS color space.</p>"},{"location":"reference/#Pylette.Color.hsv","title":"<code>hsv: tuple[float, float, float]</code>  <code>property</code>","text":"<p>Converts the RGB color to HSV color space.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The color values in HSV color space.</p>"},{"location":"reference/#Pylette.Color.luminance","title":"<code>luminance: float</code>  <code>property</code>","text":"<p>Calculates the luminance of the color.</p> <p>Returns: float: The luminance of the color.</p>"},{"location":"reference/#Pylette.Color.__init__","title":"<code>__init__</code>","text":"<p>Initializes a Color object with RGBA values and frequency.</p> <p>Parameters:</p> Name Type Description Default <code>rgba</code> <code>tuple[int, ...]</code> <p>A tuple of RGBA values.</p> required <code>frequency</code> <code>float</code> <p>The frequency of the color.</p> required Source code in <code>Pylette/src/color.py</code> <pre><code>def __init__(self, rgba: tuple[int, ...], frequency: float):\n    \"\"\"\n    Initializes a Color object with RGBA values and frequency.\n\n    Parameters:\n        rgba (tuple[int, ...]): A tuple of RGBA values.\n        frequency (float): The frequency of the color.\n    \"\"\"\n    assert len(rgba) == 4, \"RGBA values must be a tuple of length 4\"\n    *rgb, alpha = rgba\n    self.rgb = cast(tuple[int, int, int], rgb)\n    self.rgba = rgba\n    self.a = alpha\n    self.freq: float = frequency\n    self.weight = alpha / 255.0\n</code></pre>"},{"location":"reference/#Pylette.Color.__lt__","title":"<code>__lt__</code>","text":"<p>Compares the frequency of this color with another color.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Color</code> <p>The other Color object to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the frequency of this color is less than the frequency of the other color, False otherwise.</p> Source code in <code>Pylette/src/color.py</code> <pre><code>def __lt__(self, other: \"Color\") -&gt; bool:\n    \"\"\"\n    Compares the frequency of this color with another color.\n\n    Parameters:\n        other (Color): The other Color object to compare with.\n\n    Returns:\n        bool: True if the frequency of this color is less than the frequency of the other color, False otherwise.\n    \"\"\"\n    return self.freq &lt; other.freq\n</code></pre>"},{"location":"reference/#Pylette.Color.display","title":"<code>display</code>","text":"<p>Displays the color in a window of specified width and height.</p> <p>Parameters: w (int): Width of the window in pixels. h (int): Height of the window in pixels.</p> Source code in <code>Pylette/src/color.py</code> <pre><code>def display(self, w: int = 50, h: int = 50) -&gt; None:\n    \"\"\"\n    Displays the color in a window of specified width and height.\n\n    Parameters:\n    w (int): Width of the window in pixels.\n    h (int): Height of the window in pixels.\n    \"\"\"\n\n    from PIL import Image\n\n    img = Image.new(\"RGBA\", size=(w, h), color=self.rgba)\n    img.show()\n</code></pre>"},{"location":"reference/#Pylette.Color.get_colors","title":"<code>get_colors</code>","text":"<p>Returns the color values in the specified color space.</p> <p>Parameters:</p> Name Type Description Default <code>colorspace</code> <code>ColorSpace</code> <p>The color space to use.</p> <code>RGB</code> <p>Returns:</p> Type Description <code>tuple[int, ...] | tuple[float, ...]</code> <p>tuple[int, ...] | tuple[float, ...]: The color values in the specified color space.</p> Source code in <code>Pylette/src/color.py</code> <pre><code>def get_colors(self, colorspace: ColorSpace = ColorSpace.RGB) -&gt; tuple[int, ...] | tuple[float, ...]:\n    \"\"\"\n    Returns the color values in the specified color space.\n\n    Parameters:\n        colorspace (ColorSpace): The color space to use.\n\n    Returns:\n        tuple[int, ...] | tuple[float, ...]: The color values in the specified color space.\n    \"\"\"\n    colors = {ColorSpace.RGB: self.rgb, ColorSpace.HSV: self.hsv, ColorSpace.HLS: self.hls}\n    return colors[colorspace]\n</code></pre>"},{"location":"reference/#core-types","title":"Core Types:","text":""},{"location":"reference/#Pylette.types.ArrayImage","title":"<code>Pylette.types.ArrayImage: TypeAlias = NDArray[np.uint8]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ArrayLike","title":"<code>Pylette.types.ArrayLike</code>","text":"<p>Protocol for array-like objects.</p> Source code in <code>Pylette/src/types.py</code> <pre><code>class ArrayLike(Protocol):\n    \"\"\"Protocol for array-like objects.\"\"\"\n\n    def __array__(self) -&gt; NDArray[np.uint8]: ...\n</code></pre>"},{"location":"reference/#Pylette.types.BatchResult","title":"<code>Pylette.types.BatchResult</code>  <code>dataclass</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>@dataclass\nclass BatchResult:\n    source: ImageInput\n    result: \"Palette | None\" = None\n    exception: Exception | None = None\n\n    @property\n    def success(self) -&gt; bool:\n        return self.result is not None\n\n    @property\n    def palette(self) -&gt; \"Palette | None\":\n        return self.result\n\n    @property\n    def error(self) -&gt; \"Exception | None\":\n        return self.exception\n</code></pre>"},{"location":"reference/#Pylette.types.BytesImage","title":"<code>Pylette.types.BytesImage: TypeAlias = bytes</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ColorArray","title":"<code>Pylette.types.ColorArray: TypeAlias = NDArray[np.uint8]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ColorSpace","title":"<code>Pylette.types.ColorSpace</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class ColorSpace(str, Enum):\n    RGB = \"rgb\"\n    HSV = \"hsv\"\n    HLS = \"hls\"\n</code></pre>"},{"location":"reference/#Pylette.types.ColorTuple","title":"<code>Pylette.types.ColorTuple: TypeAlias = RGBTuple | RGBATuple</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.CV2Image","title":"<code>Pylette.types.CV2Image: TypeAlias = MatLike</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ExtractionMethod","title":"<code>Pylette.types.ExtractionMethod</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class ExtractionMethod(str, Enum):\n    MC = \"MedianCut\"\n    KM = \"KMeans\"\n</code></pre>"},{"location":"reference/#Pylette.types.ExtractionParams","title":"<code>Pylette.types.ExtractionParams</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class ExtractionParams(TypedDict):\n    palette_size: int\n    mode: ExtractionMethod\n    sort_mode: str | None\n    resize: bool\n    alpha_mask_threshold: int | None\n</code></pre>"},{"location":"reference/#Pylette.types.FloatArray","title":"<code>Pylette.types.FloatArray: TypeAlias = NDArray[np.floating[Any]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ImageInfo","title":"<code>Pylette.types.ImageInfo</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class ImageInfo(TypedDict):\n    original_size: tuple[int, int]\n    processed_size: tuple[int, int]\n    format: str | None\n    mode: str\n    has_alpha: bool\n</code></pre>"},{"location":"reference/#Pylette.types.ImageInput","title":"<code>Pylette.types.ImageInput: TypeAlias = PathLikeImage | URLImage | BytesImage | ArrayImage | PILImage | CV2Image</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ImageLike","title":"<code>Pylette.types.ImageLike</code>","text":"<p>Protocol for image-like objects that can be converted to PIL Image.</p> Source code in <code>Pylette/src/types.py</code> <pre><code>class ImageLike(Protocol):\n    \"\"\"Protocol for image-like objects that can be converted to PIL Image.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#Pylette.types.IntArray","title":"<code>Pylette.types.IntArray: TypeAlias = NDArray[np.integer[Any]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.PaletteMetaData","title":"<code>Pylette.types.PaletteMetaData</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class PaletteMetaData(TypedDict):\n    image_source: str\n    source_type: SourceType\n    extraction_params: ExtractionParams\n    image_info: ImageInfo\n    processing_stats: ProcessingStats\n</code></pre>"},{"location":"reference/#Pylette.types.PathLikeImage","title":"<code>Pylette.types.PathLikeImage: TypeAlias = str | Path</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.PILImage","title":"<code>Pylette.types.PILImage: TypeAlias = Image.Image</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.ProcessingStats","title":"<code>Pylette.types.ProcessingStats</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class ProcessingStats(TypedDict):\n    total_pixels: int\n    valid_pixels: int\n    extraction_time: float | None\n    timestamp: str\n</code></pre>"},{"location":"reference/#Pylette.types.RGBATuple","title":"<code>Pylette.types.RGBATuple: TypeAlias = tuple[int, int, int, int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.RGBTuple","title":"<code>Pylette.types.RGBTuple: TypeAlias = tuple[int, int, int]</code>  <code>module-attribute</code>","text":""},{"location":"reference/#Pylette.types.SourceType","title":"<code>Pylette.types.SourceType</code>","text":"Source code in <code>Pylette/src/types.py</code> <pre><code>class SourceType(str, Enum):\n    FILE_PATH = \"file_path\"\n    URL = \"url\"\n    BYTES = \"bytes\"\n    PIL_IMAGE = \"pil_image\"\n    NUMPY_ARRAY = \"numpy_array\"\n    CV2_IMAGE = \"cv2_image\"\n    UNKNOWN = \"unknown\"\n</code></pre>"},{"location":"reference/#Pylette.types.URLImage","title":"<code>Pylette.types.URLImage: TypeAlias = str</code>  <code>module-attribute</code>","text":""}]}